<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <title>
    
    Go操作MongoDB尝试 - 
    Undertaker&#39;s Blog
  </title>
  <meta property="og:title" content="Go操作MongoDB尝试 - Undertaker&#39;s Blog" />
  <meta property="og:site_name" content="Undertaker&#39;s Blog" />

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  

  <meta property="og:type" content="article" />


  
  <link rel="shortcut icon" href="/mylogo.ico" />
  

  

  
  <link rel="canonical" href="https://undertak33r.github.io/2025/09/28/Go%E6%93%8D%E4%BD%9CMongoDB%E5%B0%9D%E8%AF%95/">
  <meta name="og:url" content="https://undertak33r.github.io/2025/09/28/Go%E6%93%8D%E4%BD%9CMongoDB%E5%B0%9D%E8%AF%95/">
  
  <!-- 现代化字体加载 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">
  
  <!-- particles.js 库 -->
  <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
  
  
<link rel="stylesheet" href="/css/style.css">


<meta name="generator" content="Hexo 8.0.0"></head>

<body>
  

  <div class="title">
  <img class="title_img" alt="Title image" width="300" height="300" src="/images/mylogo.jpg" /><br>
  <div id="site_title">Undertaker's Blog</div>
</div>
  <div class="navi">
  <a id="navi_item_title" href="/#" class="menu-item-link">
    [主页]
  </a>
  <a id="navi_item_tags" href="/tags" class="menu-item-link">
    [标签]
  </a>
  <a id="navi_item_about" href="/about" class="menu-item-link">
    [关于]
  </a>
  <a id="navi_item_search" href="/search" class="menu-item-link">
    [搜索]
  </a>
  
</div>

<hr />

  <div class="main">
    
<link rel="stylesheet" href="/css/post.css">

<post>

  <div class="post_title">
    Go操作MongoDB尝试
  </div>

  <br /><br />

  <div id="post_content">
    <p>一般来说，写项目时候都会用到数据库来做数据的持久化，大家基本上都是用MySQL，提到NoSQL的话，大家会想到Redis。虽然嘛也很够用，但是在最近AI项目越来越流行的情况下，我们要和大模型的接口进行交互，频繁的用到json格式的数据，这种情况下以bson格式存储数据会更加方便。而且怎么说呢，学点新技术来说也不错。<br>前天和朋友逛的时候聊到mongoDB，他说高手都用mongoDB，不管它说的是真的假的，实践一下总没错。</p>
<h3 id="什么是mongoDB介绍"><a href="#什么是mongoDB介绍" class="headerlink" title="什么是mongoDB介绍"></a>什么是mongoDB介绍</h3><ul>
<li>mongoDB是一个开源的NoSQL数据库，它使用JSON（JavaScript Object Notation）格式存储数据，并且支持查询、索引、更新和删除数据。mongoDB是一个文档型数据库，每个文档（document）是一个键值对（key-value）结构，它可以包含任意数量的字段，并且每个字段都可以包含任意类型的值。mongoDB是一个分布式数据库，它可以 horizontally scale（水平扩展），并且可以自动进行</li>
</ul>
<p>前面忘了后面忘了中间忘了，这个介绍只是水下字数，重点还是操作和怎么在需要它的场景下操作它。首先我们先配置一下MongoDB，用docker-compose来配置。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mongodb:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mongo:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mongodb_demo</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;27017:27017&quot;</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">mongodb_data:</span><br></code></pre></td></tr></table></figure>
<p>这里只实现最简单的拉取镜像和容器创建，如果有需要可以进行用户和密码设置之类的，但现在暂时先不用，主要来看看具体操作数据库。</p>
<p>创建一个go项目，然后创建一个main.go文件，这里我直接在项目根目录下创建一个main.go文件，然后打开main.go文件，添加以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;context&quot;</span><br>	<span class="hljs-string">&quot;go.mongodb.org/mongo-driver/mongo&quot;</span><br>	<span class="hljs-string">&quot;go.mongodb.org/mongo-driver/mongo/options&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">// 和mongodb建立连接</span><br>	client, err := mongo.Connect(context.TODO(), options.Client().ApplyURI(<span class="hljs-string">&quot;mongodb://localhost:27017&quot;</span>))<br>	<span class="hljs-keyword">defer</span> client.Disconnect(context.TODO())<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-built_in">panic</span>(err)<br>	&#125;<br>	<span class="hljs-comment">// 看看是否连接成功</span><br>	client.Ping(context.TODO(), <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此处代码和mongoDB进行连接，然后记得调用client.Disconnect(context.TODO())结束连接。然后调用Ping方法看看有没有成功连接。</p>
<blockquote>
<p>func Connect(ctx context.Context, opts …*options.ClientOptions) (<em>Client, error)<br>选项设置：ClientOptions 的 Set</em> 方法调用顺序关键，后调用的会覆盖先前设置（含 ApplyURI），以此控制选项优先级。<br>选项合并：通过 options.MergeClientOptions 处理参数，会整体覆盖先前选项字段，不支持部分覆盖（如前一选项设用户名、后一仅设密码，合并后用户名为空）。<br>客户端行为：NewClient 不做 I&#x2F;O 操作，仅校验选项；Client.Connect 启动后台协程监控部署，主协程无 I&#x2F;O 避免阻塞，且服务不可用时也不返回错误。<br>连接验证：需通过 Client.Ping 方法验证连接是否成功及配置是否正确。</p>
</blockquote>
<h4 id="创建一个Collection"><a href="#创建一个Collection" class="headerlink" title="创建一个Collection"></a>创建一个Collection</h4><p>Collection（集合） 是 MongoDB 中的一个逻辑容器，用来存储相关的 document（文档）<br>类似于关系型数据库（如 MySQL）中的 表（table） 的概念。</p>
<p>特点 ：</p>
<ul>
<li>无固定结构：同一个 collection 中的 document 可以有不同的字段结构</li>
<li>动态创建：当向一个不存在的 collection 插入数据时，MongoDB 会自动创建该 collection</li>
<li>独立存在：每个 collection 都属于一个特定的 database（数据库）</li>
</ul>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 在 Go 代码中操作 collection</span><br>collection := client.Database(<span class="hljs-string">&quot;testdb&quot;</span>).Collection(<span class="hljs-string">&quot;users&quot;</span>)<br></code></pre></td></tr></table></figure>

<h2 id="CRUD尝试"><a href="#CRUD尝试" class="headerlink" title="CRUD尝试"></a>CRUD尝试</h2><p>创建一个Collection之后，我们就可以开始尝试CRUD了。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//func (coll *Collection) InsertOne(ctx context.Context, document interface&#123;&#125;, opts ...*options.InsertOneOptions) (*InsertOneResult, error)</span><br>one, err := collection.InsertOne(context.TODO(), bson.M&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span>&#125;) <span class="hljs-comment">//one 是一个包裹了新插入数据生成的id的struct</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>记得导入”go.mongodb.org&#x2F;mongo-driver&#x2F;bson”</p>
</blockquote>
<p>除了InsertOne方法，还有InsertMany方法，可以一次插入多个数据。<br>不过在进一步之前，我们需要了解bson是什么<br>bson是MongoDB的文档格式，它使用JSON语法，但有如下区别：</p>
<ul>
<li>bson支持64位整数，JSON不支持</li>
<li>bson支持二进制数据，JSON不支持</li>
<li>bson支持嵌套对象，JSON不支持</li>
<li>bson支持时间，JSON不支持</li>
<li>bson支持正则表达式，JSON不支持</li>
<li>bson支持对象ID，JSON不支持</li>
</ul>
<p>而从实用性角度出发我们得了解一下bson包里面都有什么，就上上面用到的这个bson.M</p>
<h4 id="基本数据类型："><a href="#基本数据类型：" class="headerlink" title="基本数据类型："></a>基本数据类型：</h4><ul>
<li>bson.M - 无序的 map[string]interface{}，最常用的文档类型</li>
<li>bson.D - 有序的 []bson.E 切片，保持字段顺序</li>
<li>bson.A - 有序的 []interface{} 切片，用于数组</li>
<li>bson.E - 单个元素 struct{Key string; Value interface{}}</li>
</ul>
<p>我们先了解这些基本类型，其他的类型再说。<br>顺序不顺序什么的我暂时也不清楚，边看边学先。</p>
<p>接下来是创建多个文档,InsertMany接受的第二个参数documents是空接口的切片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">users := []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>	bson.M&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;undertaker&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-string">&quot;male&quot;</span>&#125;,<br>	bson.M&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;violet&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-string">&quot;male&quot;</span>&#125;,<br>&#125;<br>_, err = collection.InsertMany(context.TODO(), users)<br></code></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>万里长征第一步创建数据，已经完成，接下来我们就可以尝试把数据库中的数据读出来了😋</p>
<p>Find函数需要接受一个filter来找相关的数据，类似于 SQL 中的 WHERE 子句</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//func (coll *Collection) FindOne(ctx context.Context, filter interface&#123;&#125;, opts ...*options.FindOneOptions) *SingleResult</span><br>filter := bson.M&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;undertaker&quot;</span>&#125;<br>find := collection.FindOne(context.TODO(), filter)<br><span class="hljs-keyword">if</span> find.Err() != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">var</span> result bson.M<br>find.Decode(&amp;result)<br>fmt.Println(result)<br></code></pre></td></tr></table></figure>
<p>collection.FindOne方法返回的是一个SingleResult，SingleResult是一个结构体，里面有Decode方法，这个方法可以将查询到的数据解码到result变量中。<br>如果查询不到数据，那么SingleResult.Decode方法就会返回一个空的map[]。<br>如果是collection.Find方法，返回的就是*mongo.Cursor，我们可以遍历Cursor解码来获取数据。</p>
<ul>
<li>Find函数比FindOne函数处理要不一样很多</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go">filter := bson.M&#123;<span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-string">&quot;male&quot;</span>&#125;<br>find, err := collection.Find(context.TODO(), filter)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>	<span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">var</span> result []bson.M<br><span class="hljs-keyword">for</span> find.Next(context.TODO()) &#123;<br>	<span class="hljs-keyword">var</span> temp bson.M<br>	err := find.Decode(&amp;temp)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	result = <span class="hljs-built_in">append</span>(result, temp)<br>&#125;<br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> result &#123;<br>	fmt.Println(item[<span class="hljs-string">&quot;name&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>Cursor 对象内部维护一个当前文档的指针<br>Next 方法作用：<br>find.Next(context.TODO()) 将游标移动到下一个文档位置 返回 true 表示还有文档可读，false 表示已到达末尾.<br>可以类比成刚返回的Cursor对象处于一个哨兵的状态</p>
</blockquote>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>没有想到查询居然有点新鲜的概念,在看之前也没太想得到。不过经历了查询我们可以开始更新数据的尝试了😋<br>更新有这些方法：</p>
<ul>
<li>UpdateOne</li>
<li>UpdateMany</li>
<li>ReplaceOne</li>
</ul>
<p>相比于查询，更新操作的返回值就很统一，叫UpdateResult。非常的直白😀<br>为什么更新函数我要先讲返回值呢？因为这个返回值不赖，能从里面看出更新操作的一些场景会发生什么。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> UpdateResult <span class="hljs-keyword">struct</span> &#123;<br>	MatchedCount  <span class="hljs-type">int64</span>       <span class="hljs-comment">// 与筛选条件匹配的文档数量。</span><br>	ModifiedCount <span class="hljs-type">int64</span>       <span class="hljs-comment">// 被操作修改的文档数量。</span><br>	UpsertedCount <span class="hljs-type">int64</span>       <span class="hljs-comment">// 被操作插入的文档数量。</span><br>	UpsertedID    <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// 插入文档的_id字段，如果没有执行插入操作则为nil。</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果没有匹配到筛选条件，那么MatchedCount为0，ModifiedCount为0，UpsertedCount为0，UpsertedID为nil<br>这里很奇怪啊，一般能想到的就是匹配不到才需要插入，但是这里没有匹配到，那么UpsertedCount为0，UpsertedID为nil，那这俩存在的意义？<br>答案是这里需要设置Upsert参数为true</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">opts := options.Update().SetUpsert(<span class="hljs-literal">true</span>)<br>filter := bson.M&#123;<span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-string">&quot;female&quot;</span>&#125;<br>update := bson.M&#123;<span class="hljs-string">&quot;$set&quot;</span>: bson.M&#123;<span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">31</span>&#125;&#125;<br>find, err := collection.UpdateOne(context.TODO(), filter, update, opts)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>	<span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(find.UpsertedID)<br></code></pre></td></tr></table></figure>
<p>这样如果没有匹配到数值就会插入一个新文档，并且返回插入的文档的_id字段。<br>而且你看，这里的opts的使用在前面的查询和创建函数的参数需求里是一个可选参数，前面没有解释怎么用，这里就是一个例子。</p>
<p>停停停，这更新函数的参数的filter能理解，这个update参数是在？怎么有dollar🤑<br>这里解释一下，这里是更新操作的操作符，更新除了设置值还有一些别的需求嘛。这里拉一些常用的更新操作符：</p>
<ul>
<li>“$set”：设置字段值</li>
<li>“$unset”：删除字段</li>
<li>“$inc”：增加字段值</li>
<li>“$push”：向数组添加元素</li>
<li>“$pull”：从数组移除元素</li>
<li>“$addToSet” ：向数组添加元素，如果元素已经存在，则不添加<br>举个例子：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//update := bson.M&#123;&quot;$unset&quot;: bson.M&#123;&quot;age&quot;: &quot;&quot;&#125;&#125; // [ &#123; &quot;sex&quot;: &quot;female&quot; &#125; ]</span><br><span class="hljs-comment">//update := bson.M&#123;&quot;$inc&quot;: bson.M&#123;&quot;age&quot;: 1&#125;&#125; //[ &#123; &quot;age&quot;: 1, &quot;sex&quot;: &quot;female&quot; &#125; ]</span><br><span class="hljs-comment">//update := bson.M&#123;&quot;$push&quot;: bson.M&#123;&quot;hobbies&quot;: &quot;swimming&quot;&#125;&#125; //[ &#123; &quot;age&quot;: 64, &quot;sex&quot;: &quot;female&quot;, &quot;hobbies&quot;: [&quot;swimming&quot;] &#125; ]</span><br><span class="hljs-comment">//update := bson.M&#123;&quot;$pull&quot;: bson.M&#123;&quot;hobbies&quot;: &quot;swimming&quot;&#125;&#125; //[ &#123; &quot;age&quot;: 64, &quot;sex&quot;: &quot;female&quot; &#125;,&quot;hobbies&quot;: []]</span><br>find, err := collection.UpdateOne(context.TODO(), filter, update, opts)<br></code></pre></td></tr></table></figure>
<p>如何，现在对更新操作大概知道使用方法了🙌</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除有这些方法：</p>
<ul>
<li>DeleteOne</li>
<li>DeleteMany </li>
<li>Drop &#x2F;&#x2F;删除集合，且删除不存在的集合也是安全的</li>
</ul>
<p>Drop的使用很简单，就是collection.Drop(context.TODO())，这样整个collection都会被删掉了。提示一遍，collection就是你在操作的类似数据表的东西</p>
<p>来看看另外两个删除方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">filter := bson.M&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;violet&quot;</span>&#125;<br>_, err = collection.DeleteOne(context.TODO(), filter)<br></code></pre></td></tr></table></figure>
<p>感觉十分好理解啊<br>运行之后第一个叫violet的对象被删除了<br>如果是删除多个对象，那么DeleteMany方法会删除所有匹配的文档<br>返回值：DeleteResult 记录了被删除的文档数量</p>
<p>完事了，删除就是这么简单🤭</p>
<p>以上就是mongoDB操作的尝试，个人感觉是覆盖了主要的基础使用场景的，希望对大家有用。</p>
<hr>
<p>你以为就完事了吗？</p>
<p>了解完这些基础的使用场景，那么我们开始尝试一些性能和安全角度的场景</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>和其他的一些数据库一样，mongoDB也支持索引<br>索引在读多写少的场景下性能会提高很多<br>对于写入频繁的场景，索引会增加写入开销<br>MongoDB 使用 B-tree（B树）数据结构来组织索引<br>通过索引可以将查询时间复杂度从 O(n) 降低到 O(log n)<br>索引类型：</p>
<ul>
<li>单字段索引：对单个字段建立索引</li>
<li>复合索引：对多个字段组合建立索引</li>
<li>文本索引：支持文本搜索</li>
<li>地理空间索引：支持地理位置查询</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建单字段索引</span><br>indexModel := mongo.IndexModel&#123;<br>    Keys: bson.D&#123;&#123;<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-number">1</span>&#125;&#125;, <span class="hljs-comment">// 1 为升序，-1 为降序</span><br>&#125;<br>_, err := collection.Indexes().CreateOne(context.TODO(), indexModel)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>索引的创建和删除都是通过Indexes()方法来实现的</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>MongoDB 从 4.0 版本开始支持多文档事务<br>事务确保在单个操作中对多个文档的修改要么全部成功，要么全部回滚<br>在分布式环境中，事务可以保证跨多个分片的操作一致性</p>
<p>ACID特性</p>
<ul>
<li>原子性（Atomicity）：事务中的所有操作要么全部成功，要么全部失败回滚</li>
<li>一致性（Consistency）：事务执行前后，数据库从一个一致状态转换到另一个一致状态</li>
<li>隔离性（Isolation）：多个事务并发执行时，一个事务的操作不会被其他事务干扰</li>
<li>持久性（Durability）：事务一旦提交，对数据库的改变是永久性的</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 典型的转账场景</span><br>err = client.UseSession(context.TODO(), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(sessionContext mongo.SessionContext)</span></span> <span class="hljs-type">error</span> &#123;<br>	err := sessionContext.StartTransaction()<span class="hljs-comment">// 开启事务</span><br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> err<br>	&#125;<br><br>	<span class="hljs-comment">// 从账户A扣款</span><br>	_, err = collection.UpdateOne(<br>		sessionContext,<br>		bson.M&#123;<span class="hljs-string">&quot;account&quot;</span>: <span class="hljs-string">&quot;A&quot;</span>&#125;,<br>		bson.M&#123;<span class="hljs-string">&quot;$inc&quot;</span>: bson.M&#123;<span class="hljs-string">&quot;balance&quot;</span>: <span class="hljs-number">-100</span>&#125;&#125;)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		sessionContext.AbortTransaction(sessionContext)<span class="hljs-comment">// 事务回滚</span><br>		<span class="hljs-keyword">return</span> err<br>	&#125;<br><br>	<span class="hljs-comment">// 向账户B加款</span><br>	_, err = collection.UpdateOne(<br>		sessionContext,<br>		bson.M&#123;<span class="hljs-string">&quot;account&quot;</span>: <span class="hljs-string">&quot;B&quot;</span>&#125;,<br>		bson.M&#123;<span class="hljs-string">&quot;$inc&quot;</span>: bson.M&#123;<span class="hljs-string">&quot;balance&quot;</span>: <span class="hljs-number">100</span>&#125;&#125;)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		sessionContext.AbortTransaction(sessionContext)<br>		<span class="hljs-keyword">return</span> err<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> sessionContext.CommitTransaction(sessionContext)<span class="hljs-comment">// 事务提交</span><br>&#125;)<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>使用副本集模式启动 MongoDB 才可以使用事务<br>副本集模式简述<br>副本集（Replica Set）是 MongoDB 提供的一种高可用性部署模式，具有以下特点：<br>核心特性<br>数据冗余：多个 MongoDB 实例维护相同的数据集，提供数据备份<br>自动故障转移：当主节点故障时，自动选举新的主节点保证服务可用<br>读写分离：支持将读操作分发到从节点，提高读取性能<br>成员角色<br>Primary（主节点）：处理所有写操作和默认的读操作<br>Secondary（从节点）：复制主节点数据，可处理读操作<br>Arbiter（仲裁节点）：参与选举投票，不存储数据<br>优势<br>高可用性：自动检测和恢复节点故障<br>数据安全：多副本保证数据不丢失<br>读扩展：支持读请求负载均衡<br>副本集是 MongoDB 生产环境推荐的部署方式，能有效保障数据安全和服务连续性。</p>
</blockquote>

  </div>

  <br />

  
  <br /><br />


  

<div id="copyright">

  <a id="license-image" rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img height="15" width="80" alt="知识共享 署名-非商业性使用-相同方式共享 4.0 国际许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" />
  </a>

  <p id="license-word-hyper">
    本作品采用
    <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
    知识共享 署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
    进行许可。
  </p>
</div>

  <div id="top">
  <div onclick="window.scrollTo({top: 0, behavior: 'smooth'})">▲</div>
  <div onclick="document.getElementById('footer').scrollIntoView({behavior: 'smooth'})">▼</div>
</div>
  

</post>
  </div>

  <foot id="footer">
  <hr class="boldline" />
  <br>

  <p class="center font">
    
    <a target="_blank" rel="noopener" href="https://github.com/UndertaK33r" aria-label="GitHub">
  <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
   <path class="icon_path" d="M427.392 853.504a61.44 61.44 0 0 1-1.450667 15.530667 92.586667 92.586667 0 0 1-10.965333 27.605333c-15.061333 25.301333-40.661333 42.154667-73.642667 42.154667-77.653333 0-108.117333-38.101333-146.261333-133.504C169.216 740.693333 157.013333 725.461333 128 725.461333v-85.333333c77.653333 0 108.117333 38.101333 146.261333 133.504 25.856 64.597333 38.058667 79.786667 67.072 79.786667 0-12.373333-0.170667-23.296-0.512-38.144-0.853333-34.816-0.938667-41.941333 0.554667-51.2 0.64-20.352 5.888-34.773333 16.384-49.066667-95.232-20.736-159.445333-63.573333-196.309333-132.992l-13.824-32.426667C134.186667 510.848 128 467.072 128 416.426667c0-58.24 17.749333-110.336 50.944-153.856-10.368-41.386667-8.96-91.989333 13.909333-149.077334l7.466667-18.688 19.2-6.101333c2.56-0.853333 5.632-1.578667 9.301333-2.133333 37.290667-5.888 90.325333 8.106667 159.701334 52.48a565.930667 565.930667 0 0 1 127.274666-14.208c38.741333 0 77.226667 3.882667 114.048 11.605333 67.456-42.24 119.04-55.509333 155.306667-49.92 3.626667 0.597333 6.741333 1.322667 9.258667 2.133333l19.285333 6.101334 7.466667 18.773333c20.010667 50.218667 23.424 96.469333 16.128 136.96C875.434667 296.32 896 352.597333 896 416.512c0 53.888-3.84 94.378667-14.933333 133.802667l-11.733334 32.170666c-30.677333 69.333333-98.304 112.64-202.538666 133.248 10.837333 15.018667 15.872 30.250667 15.872 52.394667v42.666667l-0.042667 42.666666a13.013333 13.013333 0 0 0 0.341333 2.730667L682.666667 938.794667c-36.352 0-63.36-17.706667-76.672-45.653334a88.277333 88.277333 0 0 1-8.661334-40.277333v-84.736c0-3.584-0.128-3.797333-8.832-12.501333-23.296-23.296-33.834667-40.874667-33.834666-72.832v-38.613334l38.4-3.84c114.346667-11.52 176.512-43.221333 197.12-89.6l9.6-26.325333c7.68-27.562667 10.88-61.098667 10.88-107.946667 0-49.706667-17.365333-90.837333-50.218667-123.648L742.4 274.773333l7.381333-24.448c6.528-21.717333 8.106667-47.402667 1.152-76.714666a158.634667 158.634667 0 0 0-3.584 0.938666c-22.826667 6.4-51.370667 20.053333-85.76 43.008l-15.658666 10.453334-18.304-4.522667a467.754667 467.754667 0 0 0-111.829334-13.269333c-42.709333 0-84.906667 5.418667-123.946666 16.042666l-19.029334 5.205334-16.256-11.136c-35.541333-24.32-65.109333-38.826667-88.746666-45.568a158.293333 158.293333 0 0 0-4.864-1.28c-8.234667 33.92-4.992 61.781333 3.413333 82.688l9.984 25.088-18.346667 19.797333C228.693333 332.629333 213.333333 370.986667 213.333333 416.512c0 41.685333 4.864 76.202667 13.824 102.229333l11.178667 26.453334c27.904 52.352 87.168 83.84 192.853333 95.146666l38.144 4.096v38.357334c0 32-10.538667 49.536-33.834666 72.832-8.704 8.704-8.832 8.96-8.832 12.501333l-0.725334 7.893333c-0.512 2.56-0.512 9.258667 0.170667 37.205334 0.298667 12.8 0.469333 22.997333 0.554667 33.621333a33.962667 33.962667 0 0 1 0.725333 6.656z"/>
  </svg>
 </a>

    
    
    <a href="mailto:2331627921@qq.com" aria-label="Email">
  <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <path d="M513.78 602.99c-27.28 0.45-53.79-9.09-74.53-26.83l-65.96-56.64c-15.64-13.37-17.48-36.9-4.1-52.54 13.38-15.65 36.9-17.48 52.54-4.1l65.96 56.64c13.68 11.1 33.27 11.1 46.95 0L881.2 253.08l-708.02-2.61c-20.58 0-37.26-16.69-37.26-37.26s16.68-37.26 37.26-37.26H881.2c41.09-2.36 76.32 29.05 78.67 70.14a74.519 74.519 0 0 1-32.46 65.87L580.86 578.38a111.842 111.842 0 0 1-67.08 24.61z m444.57 133.4V438.28c0-20.58-16.68-37.26-37.26-37.26s-37.26 16.69-37.26 37.26V736.4c0 20.58-16.68 37.26-37.26 37.26h-521.7c-20.58 0-37.26 16.69-37.26 37.26s16.68 37.26 37.26 37.26h521.7c61.72 0.01 111.78-50.05 111.78-111.79zM362.12 363.75c0-20.58-16.68-37.26-37.26-37.26h-223.6c-20.58 0-37.26 16.69-37.26 37.26s16.68 37.26 37.26 37.26h223.59c20.58 0.01 37.27-16.68 37.27-37.26z m0 298.12c0-20.58-16.68-37.26-37.26-37.26h-111.8c-20.58 0-37.26 16.69-37.26 37.26s16.68 37.26 37.26 37.26h111.79c20.58 0 37.27-16.69 37.27-37.26z"/>
  </svg>
</a>

    
    
    
    
    
    
    
    
    
  <p>
    <br>
  <p id="hitokoto">:D 获取中...</p>
  <script src="https://v1.hitokoto.cn/?c=a&encode=js&select=%23hitokoto" defer></script>
  <br>
  <p class="center font">
    &copy - <a href="https://UndertaK33r.github.io">UndertaK33r</a> -  2025 - Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>  Theme <a target="_blank" rel="noopener" href="https://github.com/pcrab/hexo-theme-quark"> Quark </a> 
  </p>
  
  <br />
</foot>
  
  
  
<script src="/js/perf-toggle.js"></script>

</body>

</html>